[
  {
    "id": 2749750754,
    "path": "src/app/actions/search-favorite.ts",
    "line": 68,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ  Major_\n\n<details>\n<summary>ğŸ§© Analysis chain</summary>\n\nğŸŒ Web query:\n\n`Prisma transaction default isolation level PostgreSQL race condition`\n\nğŸ’¡ Result:\n\n- **Prismaâ€™s default transaction isolation on PostgreSQL is whatever the database is configured for**â€”Prisma does **not** override it unless you set `isolationLevel`. ([prisma.io](https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai))  \n- **PostgreSQLâ€™s default isolation level is `READ COMMITTED`**, so Prisma transactions on Postgres are `READ COMMITTED` by default unless you change either the DB setting or Prismaâ€™s `isolationLevel`. ([prisma.io](https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai))  \n- Under **`READ COMMITTED`**, each statement gets its own snapshot; two `SELECT`s in the same transaction can see different committed data if other transactions commit in betweenâ€”this is a common source of race conditions (e.g., â€œcheck-then-insert/updateâ€ patterns). ([postgresql.org](https://www.postgresql.org/docs/9.5/transaction-iso.html?utm_source=openai))  \n- Prisma explicitly notes that **write conflicts can occur at `READ COMMITTED` (Postgres default)** and recommends using a higher isolation level like **`REPEATABLE READ` or `SERIALIZABLE`** to avoid certain concurrency anomalies; with `SERIALIZABLE`, Prisma may throw **P2034** (write conflict/deadlock) and you should retry the transaction. ([prisma.io](https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai))  \n\n**How to set it in Prisma (Postgres):**\n```ts\nawait prisma.$transaction(async (tx) => {\n  // ...\n}, { isolationLevel: Prisma.TransactionIsolationLevel.Serializable })\n```\n(or for batch/sequential `$transaction([...])` with the same option). ([prisma.io](https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai))\n\nCitations:\n\n- 1: https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai\n- 2: https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai\n- 3: https://www.postgresql.org/docs/9.5/transaction-iso.html?utm_source=openai\n- 4: https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai\n- 5: https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai\n\n---\n\nğŸŒ Web query:\n\n`Prisma $executeRaw FOR UPDATE locking user serialization concurrent writes`\n\nğŸ’¡ Result:\n\n`SELECT â€¦ FOR UPDATE` only *locks* rows for as long as the **current transaction** stays open. If you run it via `prisma.$executeRaw(...)` / `prisma.$queryRaw(...)` **without** wrapping it in a Prisma `$transaction`, the statement runs in its own auto-committed transaction, so the lock is released immediately (i.e., it wonâ€™t serialize concurrent writers in the way you expect).\n\n### Pattern that actually serializes concurrent writes (Postgres)\nUse an **interactive transaction**, and run the locking read + write on the **transaction client** (`tx`), not the root client:\n\n```ts\nawait prisma.$transaction(async (tx) => {\n  // lock the row\n  await tx.$queryRaw`\n    SELECT id\n    FROM \"User\"\n    WHERE id = ${userId}\n    FOR UPDATE\n  `\n\n  // now any concurrent tx trying to lock/update the same row will wait (or deadlock/timeout)\n  await tx.user.update({\n    where: { id: userId },\n    data: { /* your write */ },\n  })\n})\n```\n\nPrisma explicitly supports using raw SQL inside `$transaction`, and interactive transactions keep all queries on the same connection (required for row locks to work as intended). [1]\n\n### If youâ€™re seeing â€œserializationâ€ / write-conflict failures\nIf you set the transaction isolation level to `Serializable`, the database may abort one of the concurrent transactions; Prisma exposes this via **P2034** (â€œwrite conflict or deadlockâ€¦ retryâ€). You should catch **P2034** and retry the whole transaction. Prisma documents both `isolationLevel` on `$transaction` and the **P2034** code. [1][2]\n\n```ts\nimport { Prisma } from \"@prisma/client\"\n\nfor (let attempt = 0; attempt < 5; attempt++) {\n  try {\n    return await prisma.$transaction(\n      async (tx) => {\n        await tx.$queryRaw`SELECT id FROM \"User\" WHERE id=${userId} FOR UPDATE`\n        return tx.user.update({ where: { id: userId }, data: {/*...*/} })\n      },\n      { isolationLevel: Prisma.TransactionIsolationLevel.Serializable },\n    )\n  } catch (e: any) {\n    if (e?.code === \"P2034\") continue\n    throw e\n  }\n}\nthrow new Error(\"Too many retries\")\n```\n\n**Rule of thumb:** use `FOR UPDATE` to *block* concurrent writers on the same row; use `Serializable` to make multi-row / predicate-based logic safe, and then be prepared to retry on P2034. [1][2]\n\n**Sources:** Prisma transactions & isolation levels docs [1], Prisma error reference for P2034 [2].\n\n---\n\nğŸŒ Web query:\n\n`PostgreSQL SELECT FOR UPDATE user row lock Prisma concurrent transaction`\n\nğŸ’¡ Result:\n\nIn PostgreSQL, `SELECT â€¦ FOR UPDATE` takes a **row-level lock** on the rows returned, so concurrent transactions that try to `UPDATE/DELETE` (or lock) the same rows will **block until the first transaction ends**. The lock is held until `COMMIT`/`ROLLBACK`. ([postgresql.org](https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai))\n\n## How to do this correctly with Prisma (PostgreSQL)\n\n### 1) Use an **interactive** `$transaction` and run the locking `SELECT` via `tx.$queryRaw`\nYou **cannot** send `BEGIN; â€¦; COMMIT;` as a single `queryRaw` because Prisma uses prepared statements and Postgres rejects multiple commands in one prepared statement. ([github.com](https://github.com/prisma/prisma/discussions/21335?utm_source=openai))\n\n```ts\nimport { Prisma, PrismaClient } from \"@prisma/client\";\nconst prisma = new PrismaClient();\n\nawait prisma.$transaction(\n  async (tx) => {\n    // lock the row\n    await tx.$queryRaw`\n      SELECT id\n      FROM \"User\"\n      WHERE id = ${userId}\n      FOR UPDATE\n    `;\n\n    // do dependent reads/writes safely while lock is held\n    await tx.user.update({\n      where: { id: userId },\n      data: { balance: { increment: 1 } },\n    });\n  },\n  {\n    // optional but often recommended when correctness matters:\n    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,\n  }\n);\n```\n\nPrisma supports setting `isolationLevel` on transactions (interactive + batch), and Postgresâ€™ default is `ReadCommitted`. ([prisma.io](https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai))\n\n### 2) Prefer a *single-statement* write when possible (often simpler + fewer locks)\nIf your goal is â€œread a row then change itâ€, a single `UPDATE â€¦ WHERE â€¦ RETURNING â€¦` is usually better than â€œSELECT then UPDATEâ€, because Postgres will lock the row as part of the `UPDATE` anyway. (Row locks are acquired by `UPDATE/DELETE`.) ([postgresql.org](https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai))\n\n### 3) If youâ€™re building a queue/worker pattern, consider `FOR UPDATE SKIP LOCKED`\nThis avoids workers blocking each other by skipping already-locked rows (common for job reservation). (Same locking mechanism as `FOR UPDATE`.) ([postgresql.org](https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai))\n\n## Notes / gotchas\n- Under Postgres `READ COMMITTED` (the default), each statement sees a new snapshot; `SELECT FOR UPDATE` will lock the *current* version it finds after waiting, which can surprise people doing read-then-write logic. ([postgresql.org](https://www.postgresql.org/docs/9.6/transaction-iso.html?utm_source=openai))\n- `FOR UPDATE` can be **stronger than necessary**; if you donâ€™t need to block inserts referencing a row (FK scenarios) you may want `FOR NO KEY UPDATE`. ([cybertec-postgresql.com](https://www.cybertec-postgresql.com/en/select-for-update-considered-harmful-postgresql/?utm_source=openai))\n\nIf you share your exact concurrency scenario (counter increment, wallet transfer, â€œclaim next jobâ€, etc.), I can suggest the safest minimal-lock query pattern in Prisma.\n\nCitations:\n\n- 1: https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai\n- 2: https://github.com/prisma/prisma/discussions/21335?utm_source=openai\n- 3: https://www.prisma.io/docs/orm/prisma-client/queries/transactions?utm_source=openai\n- 4: https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai\n- 5: https://www.postgresql.org/docs/9.6/explicit-locking.html?utm_source=openai\n- 6: https://www.postgresql.org/docs/9.6/transaction-iso.html?utm_source=openai\n- 7: https://www.cybertec-postgresql.com/en/select-for-update-considered-harmful-postgresql/?utm_source=openai\n\n---\n\n\n\n</details>\n\n**ä¸Šé™15ä»¶ãƒã‚§ãƒƒã‚¯ãŒåŒæ™‚ä¿å­˜ã§ç ´ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚**\n\nPostgreSQLã®`READ COMMITTED`åˆ†é›¢ãƒ¬ãƒ™ãƒ«ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰ã§ã¯ã€åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒèµ°ã‚‹ã¨ä¸¡æ–¹ãŒ`count < 15`ã‚’æº€ãŸã—ã¦16ä»¶ä»¥ä¸Šã«ãªã‚‹ç«¶åˆãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼å˜ä½ã§æ›¸ãè¾¼ã¿ã‚’ç›´åˆ—åŒ–ã™ã‚‹ãƒ­ãƒƒã‚¯ã§å¯¾å¿œã—ã¦ãã ã•ã„ã€‚\n\n<details>\n<summary>ğŸ› ï¸ ä¾‹: Userè¡Œã‚’ãƒ­ãƒƒã‚¯ã—ã¦åŒæ™‚ä¿å­˜ã‚’ç›´åˆ—åŒ–</summary>\n\n```diff\n-    const result = await prisma.$transaction(async (tx) => {\n+    const result = await prisma.$transaction(async (tx) => {\n+      // åŒä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åŒæ™‚ä¿å­˜ã‚’ç›´åˆ—åŒ–\n+      await tx.$executeRaw`SELECT 1 FROM \"User\" WHERE id = ${userId} FOR UPDATE`;\n       // åŒã˜åå‰ã®ãŠæ°—ã«å…¥ã‚ŠãŒæ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ç¢ºèª\n       const existingFavorite = await tx.searchFavorite.findUnique({\n```\n</details>\n\nã¾ãŸã€ã‚ˆã‚Šæ˜ç¤ºçš„ã«`Serializable`åˆ†é›¢ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®šã—ã€P2034ã‚¨ãƒ©ãƒ¼æ™‚ã«å†è©¦è¡Œã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/app/actions/search-favorite.ts` around lines 27 - 65, The count-based\nlimit can be violated by concurrent transactions; to fix, inside the existing\nprisma.$transaction callback (the async tx => { ... } block in\nsearch-favorite.ts) acquire a row-level lock on the user before\nchecking/creating favorites (e.g., issue a SELECT ... FOR UPDATE against the\nUser row via tx.$executeRaw or read the user with a FOR UPDATE equivalent) so\nconcurrent transactions for the same user are serialized; keep the lock\nacquisition before tx.searchFavorite.count and the upsert/update logic\n(existingFavorite, tx.searchFavorite.update/create), and ensure the transaction\neither throws LIMIT_EXCEEDED or completes while holding the lock; alternatively\nyou may set the transaction isolation to 'Serializable' and implement retry\nlogic on Prisma P2034 errors, but prefer the user-row FOR UPDATE lock to\ndirectly serialize writes per user.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2749750757,
    "path": "src/components/search/ProductSearch.tsx",
    "line": 366,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ  Major_\n\n**ãŠæ°—ã«å…¥ã‚Šåã®å¤‰æ›´ãŒå®Ÿè³ªç„¡åŠ¹ã§ã™ã€‚**  \nç¾åœ¨ã¯åŒåã§ `renameFavorite` ã‚’å‘¼ã¶ã ã‘ãªã®ã§ã€UIã‹ã‚‰åå‰ã‚’å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚æœ€ä½é™ã€å…¥åŠ›ã‚’å—ã‘å–ã£ã¦ã‹ã‚‰å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ› ï¸ ä¾‹: æœ€ä½é™ã®å…¥åŠ›å°ç·šï¼ˆå¾Œã§å°‚ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«ã«ç½®ãæ›ãˆå¯ï¼‰</summary>\n\n```diff\n+  const handleFavoriteRename = useCallback((item: SearchFavoriteItem) => {\n+    const newName = window.prompt('æ–°ã—ã„åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', item.name);\n+    if (!newName) return;\n+    const trimmed = newName.trim();\n+    if (!trimmed || trimmed === item.name) return;\n+    renameFavorite(item.id, trimmed);\n+  }, [renameFavorite]);\n...\n-          onFavoriteRename={(item) => renameFavorite(item.id, item.name)} // åå‰å¤‰æ›´ã¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ç­‰ãŒå¿…è¦ã ãŒã€ä¸€æ—¦ç°¡æ˜“å®Ÿè£…ã¾ãŸã¯å¾Œå›ã—ã€‚ã“ã“ã§ã¯å‹åˆã‚ã›\n+          onFavoriteRename={handleFavoriteRename}\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 358 - 363, The current\nonFavoriteRename prop just re-calls renameFavorite with the same item.name, so\nusers cannot change the name; update the onFavoriteRename handler (the inline\narrow currently passing (item) => renameFavorite(item.id, item.name)) to collect\ninput (e.g. via a simple prompt or an inline input flow) and only call\nrenameFavorite(item.id, newName) when the newName is non-empty and different\nfrom item.name; ensure you reference renameFavorite and the onFavoriteRename\nprop so the component receives the new name before invoking the rename\noperation.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2749750759,
    "path": "src/components/search/ProductSearch.tsx",
    "line": null,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**ä¿å­˜çŠ¶æ…‹ã®åˆ¤å®šãŒå¸¸ã« true ã«ãªã‚Šå¾—ã¾ã™ã€‚**  \n`JSON.stringify(f.query) === JSON.stringify({ ...f.query })` ã¯å¸¸ã«ä¸€è‡´ã™ã‚‹ãŸã‚ã€favorites ãŒ1ä»¶ã§ã‚‚ã‚ã‚‹ã¨æ˜ŸãŒå¡—ã‚Šã¤ã¶ã•ã‚Œã¾ã™ã€‚ç¾åœ¨ã®æ¤œç´¢æ¡ä»¶ã¨æ¯”è¼ƒã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ› ï¸ ä¾‹: åŒä¸€ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã§æ¯”è¼ƒ</summary>\n\n```diff\n+  const buildSearchSnapshot = useCallback(() => {\n+    const snapshot: Record<string, any> = {};\n+    if (searchQuery) snapshot.q = searchQuery;\n+    if (selectedTags.length > 0) snapshot.tags = selectedTags;\n+    if (selectedNegativeTags.length > 0) snapshot.ntags = selectedNegativeTags;\n+    if (selectedAgeRatingTags.length > 0) snapshot.age_tags = selectedAgeRatingTags;\n+    if (detailedFilters && Object.keys(detailedFilters).length > 0) {\n+      snapshot.detailedFilters = detailedFilters;\n+      if (detailedFilters.category) snapshot.category = detailedFilters.category;\n+    }\n+    if (priceRange[0] > 0) snapshot.min_price = priceRange[0];\n+    if (shouldSaveMaxPrice(priceRange[1], isHighPriceFilterEnabled)) {\n+      snapshot.max_price = priceRange[1];\n+    }\n+    if (isHighPriceFilterEnabled) snapshot.high_price = true;\n+    if (isLiked) snapshot.liked = true;\n+    if (isOwned) snapshot.owned = true;\n+    if (isSearchPolySeekTagsOnly) snapshot.poly_tags = true;\n+    if (sortBy !== 'newest') snapshot.sort = sortBy;\n+    return snapshot;\n+  }, [\n+    searchQuery, selectedTags, selectedNegativeTags, selectedAgeRatingTags,\n+    detailedFilters, priceRange, isHighPriceFilterEnabled, isLiked, isOwned,\n+    isSearchPolySeekTagsOnly, sortBy\n+  ]);\n...\n-    const historyData: Record<string, any> = {};\n-    if (searchQuery) historyData.q = searchQuery;\n-    if (selectedTags.length > 0) historyData.tags = selectedTags;\n-    if (selectedNegativeTags.length > 0) historyData.ntags = selectedNegativeTags;\n-    if (selectedAgeRatingTags.length > 0) historyData.age_tags = selectedAgeRatingTags;\n-    if (detailedFilters && Object.keys(detailedFilters).length > 0) {\n-      historyData.detailedFilters = detailedFilters;\n-      if (detailedFilters.category) historyData.category = detailedFilters.category;\n-    }\n-    if (priceRange[0] > 0) historyData.min_price = priceRange[0];\n-    if (shouldSaveMaxPrice(priceRange[1], isHighPriceFilterEnabled)) {\n-       historyData.max_price = priceRange[1];\n-    }\n-    if (isHighPriceFilterEnabled) historyData.high_price = true;\n-    if (isLiked) historyData.liked = true;\n-    if (isOwned) historyData.owned = true;\n-    if (isSearchPolySeekTagsOnly) historyData.poly_tags = true;\n-    if (sortBy !== 'newest') historyData.sort = sortBy;\n+    const historyData = buildSearchSnapshot();\n...\n-  }, [\n-    searchQuery, selectedTags, selectedNegativeTags, selectedAgeRatingTags,\n-    detailedFilters, priceRange, isHighPriceFilterEnabled, isLiked, isOwned,\n-    isSearchPolySeekTagsOnly, sortBy, addHistory, originalHandleSearch\n-  ]);\n+  }, [buildSearchSnapshot, addHistory, originalHandleSearch]);\n...\n-    const historyData: Record<string, any> = {};\n-    if (searchQuery) historyData.q = searchQuery;\n-    if (selectedTags.length > 0) historyData.tags = selectedTags;\n-    if (selectedNegativeTags.length > 0) historyData.ntags = selectedNegativeTags;\n-    if (selectedAgeRatingTags.length > 0) historyData.age_tags = selectedAgeRatingTags;\n-    if (detailedFilters && Object.keys(detailedFilters).length > 0) {\n-      historyData.detailedFilters = detailedFilters;\n-      if (detailedFilters.category) historyData.category = detailedFilters.category;\n-    }\n-    if (priceRange[0] > 0) historyData.min_price = priceRange[0];\n-    if (shouldSaveMaxPrice(priceRange[1], isHighPriceFilterEnabled)) {\n-       historyData.max_price = priceRange[1];\n-    }\n-    if (isHighPriceFilterEnabled) historyData.high_price = true;\n-    if (isLiked) historyData.liked = true;\n-    if (isOwned) historyData.owned = true;\n-    if (isSearchPolySeekTagsOnly) historyData.poly_tags = true;\n-    if (sortBy !== 'newest') historyData.sort = sortBy;\n+    const historyData = buildSearchSnapshot();\n     return await addFavorite(name, historyData);\n   };\n+\n+  const currentFavoriteQuery = buildSearchSnapshot();\n+  const currentFavoriteKey = JSON.stringify(currentFavoriteQuery);\n+  const isCurrentFavorite =\n+    Object.keys(currentFavoriteQuery).length > 0 &&\n+    favorites.some(f => JSON.stringify(f.query) === currentFavoriteKey);\n...\n-          <Star className={`h-4 w-4 ${favorites.some(f => JSON.stringify(f.query) === JSON.stringify({ ...f.query /* å³å¯†ãªæ¯”è¼ƒã¯é›£ã—ã„ãŒã€ç°¡æ˜“çš„ã« */ })) ? \"fill-amber-400 text-amber-400\" : \"text-gray-500\"}`} />\n+          <Star className={`h-4 w-4 ${isCurrentFavorite ? \"fill-amber-400 text-amber-400\" : \"text-gray-500\"}`} />\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 424 - 432, The current\nfavorites check always returns true because it compares f.query to a shallow\nclone of itself; change the predicate to compare each favorite's query to the\ncurrent search criteria (e.g., replace JSON.stringify({ ...f.query }) with a\nstable snapshot of the current query state such as JSON.stringify(currentQuery)\nor use a deep equality helper like isEqual(f.query, currentQuery)); update the\nfavorites.some(...) expression inside ProductSearch (where favorites and the\nStar/Button rendering occur) to use that comparison so the star is only filled\nwhen a favorite exactly matches the current search query.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 4054c4c",
    "type": "review_comment"
  },
  {
    "id": 2749750760,
    "path": "src/components/search/TagSearchBar.tsx",
    "line": 380,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**listboxå†…ã«ã‚¿ãƒ–ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç½®ãã¨ARIAæ§‹é€ ãŒå´©ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚**  \nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªãƒ¼ãƒ€ãƒ¼ã§ option ã¨èª¤èªè­˜ã•ã‚Œã‚‹æã‚ŒãŒã‚ã‚‹ãŸã‚ã€ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ `role=\"presentation\"` ã§ç„¡è¦–ã•ã›ã‚‹ã‹ listbox å¤–ã«ç§»å‹•ã—ã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ› ï¸ æœ€å°ä¿®æ­£ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ‰±ã„ï¼‰</summary>\n\n```diff\n-          <div className=\"flex border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 sticky top-0 z-10\">\n+          <div role=\"presentation\" aria-hidden=\"true\" className=\"flex border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 sticky top-0 z-10\">\n```\n</details>\n\n<!-- suggestion_start -->\n\n<details>\n<summary>ğŸ“ Committable suggestion</summary>\n\n> â€¼ï¸ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n          {/* ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆãƒ˜ãƒƒãƒ€ãƒ¼ */}\n          <div role=\"presentation\" aria-hidden=\"true\" className=\"flex border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 sticky top-0 z-10\">\n            <button\n              type=\"button\"\n              onClick={() => setActiveTab('history')}\n              className={cn(\n                \"flex-1 px-3 py-2 text-xs font-semibold text-center transition-colors\",\n                activeTab === 'history'\n                  ? \"text-blue-600 border-b-2 border-blue-600 bg-white dark:bg-gray-900\"\n                  : \"text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700\"\n              )}\n            >\n              <div className=\"flex items-center justify-center gap-1\">\n                <History size={12} />\n                <span>å±¥æ­´</span>\n              </div>\n            </button>\n            <button\n              type=\"button\"\n              onClick={() => setActiveTab('favorites')}\n              className={cn(\n                \"flex-1 px-3 py-2 text-xs font-semibold text-center transition-colors\",\n                activeTab === 'favorites'\n                  ? \"text-amber-600 border-b-2 border-amber-600 bg-white dark:bg-gray-900\"\n                  : \"text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700\"\n              )}\n            >\n              <div className=\"flex items-center justify-center gap-1\">\n                <Star size={12} />\n                <span>ãŠæ°—ã«å…¥ã‚Š</span>\n              </div>\n            </button>\n          </div>\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/TagSearchBar.tsx` around lines 348 - 380, The tab\nheader inside TagSearchBar currently sits within the listbox and may be exposed\nas options to screen readers; update the containing div (the element with class\n\"flex border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800\nsticky top-0 z-10\" that wraps the two buttons using setActiveTab('history') and\nsetActiveTab('favorites')) to be ignored by assistive tech by adding\nrole=\"presentation\" (or move the whole header out of the listbox if you prefer\nstructural change) so the buttons are not misinterpreted as listbox options.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2749750762,
    "path": "src/hooks/useSearchFavorite.ts",
    "line": null,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**å‰Šé™¤ã®æ¥½è¦³æ›´æ–°ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒãªã„ãŸã‚UIä¸æ•´åˆãŒèµ·ãå¾—ã¾ã™ã€‚**  \nã‚µãƒ¼ãƒãƒ¼å‰Šé™¤ã«å¤±æ•—ã—ãŸéš›ã«çŠ¶æ…‹ã‚’æˆ»ã™ã‹å†å–å¾—ã™ã‚‹å‡¦ç†ãŒå¿…è¦ã§ã™ã€‚  \n\n<details>\n<summary>ğŸ› ï¸ å¤±æ•—æ™‚ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹ä¾‹</summary>\n\n```diff\n-  const removeFavorite = useCallback(async (id: string) => {\n+  const removeFavorite = useCallback(async (id: string) => {\n     if (status !== 'authenticated') return;\n \n+    const prevFavorites = favorites;\n     try {\n       // æ¥½è¦³çš„æ›´æ–°\n       setFavorites(prev => prev.filter(item => item.id !== id));\n \n       const result = await deleteFavoriteApi(id);\n       if (!result.success) {\n         // å¤±æ•—ã—ãŸã‚‰æˆ»ã™ãªã©ã®å‡¦ç†ãŒå¿…è¦ã ãŒã€ã“ã“ã§ã¯ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®ã¿\n         console.error('Failed to delete favorite on server');\n-        // å¿…è¦ãªã‚‰ãƒªãƒ­ãƒ¼ãƒ‰å‡¦ç†ã‚’å…¥ã‚Œã‚‹\n+        setFavorites(prevFavorites);\n       }\n     } catch (error) {\n       console.error('Failed to delete favorite:', error);\n+      setFavorites(prevFavorites);\n     }\n-  }, [status]);\n+  }, [status, favorites]);\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/hooks/useSearchFavorite.ts` around lines 96 - 113, The removeFavorite\noptimistic update currently mutates state without rollback; capture the previous\nfavorites before calling setFavorites in removeFavorite, then call\ndeleteFavoriteApi(id) and if result.success is false or an exception is thrown\nrestore the saved previous list (or trigger a refetch) so the UI stays\nconsistent; specifically, inside removeFavorite save prevFavorites (from\nsetFavorites callback or a local variable), perform setFavorites(prev =>\nprev.filter(...)), await deleteFavoriteApi(id), and on failure or in catch\nrestore prevFavorites via setFavorites or call the existing fetch function to\nre-sync.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2749924042,
    "path": "src/components/search/ProductSearch.tsx",
    "line": 132,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ  Major_\n\n**è©³ç´°ãƒ•ã‚£ãƒ«ã‚¿ã® falsy å€¤ãŒä¿å­˜å¯¾è±¡ã‹ã‚‰æ¼ã‚Œã¾ã™ã€‚**  \n`if (detailedFilters[key])` ã ã¨ `false` / `0` ãŒè½ã¡ã€ä¿å­˜ãƒ»å¾©å…ƒã§ãã¾ã›ã‚“ã€‚null/undefined/ç©ºæ–‡å­—ã ã‘é™¤å¤–ã™ã‚‹å½¢ã«ã—ã¦ãã ã•ã„ã€‚  \n\n\n<details>\n<summary>ğŸ› ï¸ ä¿®æ­£æ¡ˆ</summary>\n\n```diff\n-      Object.keys(detailedFilters).sort().forEach(key => {\n-        if (detailedFilters[key]) cleanFilters[key] = detailedFilters[key];\n-      });\n+      Object.keys(detailedFilters).sort().forEach(key => {\n+        const value = detailedFilters[key];\n+        if (value !== undefined && value !== null && value !== '') {\n+          cleanFilters[key] = value;\n+        }\n+      });\n```\n</details>\n\n<!-- suggestion_start -->\n\n<details>\n<summary>ğŸ“ Committable suggestion</summary>\n\n> â€¼ï¸ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n      const cleanFilters: Record<string, any> = {};\n      Object.keys(detailedFilters).sort().forEach(key => {\n        const value = detailedFilters[key];\n        if (value !== undefined && value !== null && value !== '') {\n          cleanFilters[key] = value;\n        }\n      });\n      if (Object.keys(cleanFilters).length > 0) {\n        query.detailedFilters = cleanFilters;\n        if (cleanFilters.category) query.category = cleanFilters.category;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 123 - 129, The current\nloop building cleanFilters drops falsy but valid values (e.g., false, 0) because\nit uses if (detailedFilters[key]); update the filter-preservation logic in\nProductSearch (the detailedFilters -> cleanFilters block) to only exclude null,\nundefined, and empty-string values while keeping 0/false; keep the\nObject.keys(detailedFilters).sort() iteration and ensure after assigning\nquery.detailedFilters = cleanFilters you still copy category with if\n(cleanFilters.category) replaced by a check that treats\nempty-string/null/undefined as excluded so a valid false/0 category is preserved\nas appropriate.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2749924046,
    "path": "src/components/search/ProductSearch.tsx",
    "line": 169,
    "body": "_ğŸ§¹ Nitpick_ | _ğŸ”µ Trivial_\n\n**normalize ãŒé…åˆ—ã‚’ç ´å£Šçš„ã«ã‚½ãƒ¼ãƒˆã—ã¦ state ã‚’å¤‰ç•°ã•ã›ã¾ã™ã€‚**  \n`obj.sort()` ãŒ favorites å†…é…åˆ—ã‚’ç›´æ¥ä¸¦ã¹æ›¿ãˆã‚‹ãŸã‚ render ä¸­ã®å‰¯ä½œç”¨ã«ãªã‚Šã¾ã™ã€‚ã‚³ãƒ”ãƒ¼ã—ã¦ã‹ã‚‰ã‚½ãƒ¼ãƒˆã—ã€å†å¸°çš„ã«æ­£è¦åŒ–ã™ã‚‹å½¢ã«ã—ã¦ãã ã•ã„ã€‚  \n\n\n<details>\n<summary>â™»ï¸ æ”¹å–„æ¡ˆï¼ˆéç ´å£Šï¼‹å†å¸°æ­£è¦åŒ–ï¼‰</summary>\n\n```diff\n-    const normalize = (obj: any): string => {\n-      if (obj === null || typeof obj !== 'object') return JSON.stringify(obj);\n-      if (Array.isArray(obj)) return JSON.stringify(obj.sort());\n-      return JSON.stringify(Object.keys(obj).sort().reduce((result: any, key: string) => {\n-        result[key] = obj[key];\n-        return result;\n-      }, {}));\n-    };\n+    const normalize = (value: any): any => {\n+      if (value === null || typeof value !== 'object') return value;\n+      if (Array.isArray(value)) return [...value].sort().map(normalize);\n+      return Object.keys(value).sort().reduce((result: any, key: string) => {\n+        result[key] = normalize(value[key]);\n+        return result;\n+      }, {});\n+    };\n \n-    const currentJson = normalize(currentQuery);\n-    return favorites.some(f => normalize(f.query) === currentJson);\n+    const currentJson = JSON.stringify(normalize(currentQuery));\n+    return favorites.some(f => JSON.stringify(normalize(f.query)) === currentJson);\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 152 - 166, The\nnormalize function used inside isCurrentConditionFavorited mutates arrays by\ncalling obj.sort(), which can change favorites state during render; update\nnormalize (used by isCurrentConditionFavorited/getCurrentQueryObject) to perform\na non-destructive, recursive normalization: when obj is an array, create a\nshallow copy (e.g., [...obj]) before sorting and recursively normalize each\nelement (and for objects, recursively normalize each value while sorting keys)\nso no mutation of favorites occurs and comparison remains stable.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\nâœ… Addressed in commit 9bbce20",
    "type": "review_comment"
  },
  {
    "id": 2750819498,
    "path": "src/app/actions/search-favorite.ts",
    "line": 38,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**ä¿å­˜åã¯ trim ã—ã¦ã‹ã‚‰ä¸€è²«ã—ã¦æ‰±ã†ã¹ãã§ã™**  \nå‰å¾Œç©ºç™½ãŒæ®‹ã‚‹ã¨é‡è¤‡åˆ¤å®šã‚„è¡¨ç¤ºãŒä¸å®‰å®šã«ãªã‚Šã¾ã™ã€‚æ­£è¦åŒ–ã—ãŸå€¤ã§æ¤œç´¢ãƒ»ä¿å­˜ã—ã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ’¡ ä¿®æ­£æ¡ˆ</summary>\n\n```diff\n-    // åå‰ãŒç©ºã§ãªã„ã‹ãƒã‚§ãƒƒã‚¯\n-    if (!name || name.trim() === '') {\n+    // åå‰ãŒç©ºã§ãªã„ã‹ãƒã‚§ãƒƒã‚¯\n+    const trimmedName = name.trim();\n+    if (!trimmedName) {\n       return { success: false, error: 'Name is required' };\n     }\n...\n-      const existingFavorite = await tx.searchFavorite.findUnique({\n+      const existingFavorite = await tx.searchFavorite.findUnique({\n         where: {\n           userId_name: {\n             userId,\n-            name,\n+            name: trimmedName,\n           },\n         },\n       });\n...\n-        return await tx.searchFavorite.create({\n+        return await tx.searchFavorite.create({\n           data: {\n             userId,\n-            name,\n+            name: trimmedName,\n             query: queryJson,\n           },\n         });\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/app/actions/search-favorite.ts` around lines 22 - 38, Normalize the\nincoming name by trimming (and optionally collapsing internal whitespace) before\nany checks or DB operations so duplicate detection and storage use the same\nvalue; update the code in search-favorite.ts to compute a normalizedName (use\nnormalizedName instead of name) before the empty check, before the\ntx.$executeRaw lock, in the tx.searchFavorite.findUnique where clause\n(userId_name), and when creating/updating the favorite so both reads and writes\nuse the trimmed value consistently.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 2750819504,
    "path": "src/app/actions/search-favorite.ts",
    "line": 168,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**ãƒªãƒãƒ¼ãƒ ã‚‚ trim ã—ãŸå€¤ã§æ›´æ–°ã—ã¦ãã ã•ã„**  \nç©ºç™½ä»˜ãã®é‡è¤‡ã‚„æ„å›³ã—ãªã„åå‰ãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚  \n\n<details>\n<summary>ğŸ’¡ ä¿®æ­£æ¡ˆ</summary>\n\n```diff\n-    if (!newName || newName.trim() === '') {\n+    const trimmedName = newName.trim();\n+    if (!trimmedName) {\n       return { success: false, error: 'Name is required' };\n     }\n...\n-    const existingWithName = await prisma.searchFavorite.findUnique({\n+    const existingWithName = await prisma.searchFavorite.findUnique({\n       where: {\n         userId_name: {\n           userId: session.user.id,\n-          name: newName,\n+          name: trimmedName,\n         },\n       },\n     });\n...\n-      data: {\n-        name: newName,\n-      },\n+      data: {\n+        name: trimmedName,\n+      },\n```\n</details>\n\n<!-- suggestion_start -->\n\n<details>\n<summary>ğŸ“ Committable suggestion</summary>\n\n> â€¼ï¸ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    const trimmedName = newName.trim();\n    if (!trimmedName) {\n      return { success: false, error: 'Name is required' };\n    }\n\n    // åå‰ãŒé‡è¤‡ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†è‡ªèº«ã®æ›´æ–°ã¯é™¤ãï¼‰\n    // Prismaã®updateã§Uniqueåˆ¶ç´„ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒã—ã¦ã‚‚è‰¯ã„ãŒã€\n    // äº‹å‰ã«ãƒã‚§ãƒƒã‚¯ã—ã¦åˆ†ã‹ã‚Šã‚„ã™ã„ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™\n    const existingWithName = await prisma.searchFavorite.findUnique({\n      where: {\n        userId_name: {\n          userId: session.user.id,\n          name: trimmedName,\n        },\n      },\n    });\n\n    if (existingWithName && existingWithName.id !== id) {\n      return { success: false, error: 'Name already exists' };\n    }\n\n    const result = await prisma.searchFavorite.updateMany({\n      where: {\n        id,\n        userId: session.user.id,\n      },\n      data: {\n        name: trimmedName,\n      },\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/app/actions/search-favorite.ts` around lines 141 - 168, Trim the incoming\nnewName once and use the trimmed value throughout: validate using trimmedName\n(check empty), use trimmedName in the uniqueness check via\nprisma.searchFavorite.findUnique, and set name: trimmedName in\nprisma.searchFavorite.updateMany so stored and compared values don't include\nsurrounding whitespace; keep references to session.user.id, id,\nprisma.searchFavorite.findUnique and prisma.searchFavorite.updateMany when\nmaking the change.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 2750819508,
    "path": "src/components/search/ProductSearch.tsx",
    "line": 301,
    "body": "_ğŸ§¹ Nitpick_ | _ğŸ”µ Trivial_\n\n**`handleHistorySelect`ã¨ã®é‡è¤‡ã‚³ãƒ¼ãƒ‰ã‚’ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ¤œè¨ã€‚**\n\n`handleFavoriteSelect`ã¨`handleHistorySelect`ï¼ˆ194-247è¡Œï¼‰ã¯ã»ã¼åŒä¸€ã®ãƒ­ã‚¸ãƒƒã‚¯ã§ã™ã€‚ã‚¯ã‚¨ãƒªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã™ã‚‹å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã§ã€ä¿å®ˆæ€§ãŒå‘ä¸Šã—ã¾ã™ã€‚\n\n\n<details>\n<summary>â™»ï¸ å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã®ææ¡ˆ</summary>\n\n```diff\n+  // ã‚¯ã‚¨ãƒªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰URLSearchParamsã‚’æ§‹ç¯‰ã™ã‚‹å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼\n+  const buildSearchParams = useCallback((q: Record<string, any>): URLSearchParams => {\n+    const params = new URLSearchParams();\n+\n+    if (q.q) params.append('q', String(q.q));\n+    if (q.tags) {\n+      const tags = Array.isArray(q.tags) ? q.tags.join(',') : q.tags;\n+      params.append('tags', tags);\n+    }\n+    if (q.ntags) {\n+      const ntags = Array.isArray(q.ntags) ? q.ntags.join(',') : q.ntags;\n+      params.append('negativeTags', ntags);\n+    }\n+    if (q.age_tags) {\n+      const ageTags = Array.isArray(q.age_tags) ? q.age_tags.join(',') : q.age_tags;\n+      params.append('ageRatingTags', ageTags);\n+    }\n+    if (q.detailedFilters) {\n+      const df = q.detailedFilters;\n+      if (df.category) params.append('categoryName', df.category);\n+      Object.entries(df).forEach(([key, value]) => {\n+        if (key !== 'category' && value !== undefined && value !== null && value !== '') {\n+          params.append(key, String(value));\n+        }\n+      });\n+    } else if (q.category) {\n+      params.append('categoryName', q.category);\n+    }\n+    if (q.min_price) params.append('minPrice', String(q.min_price));\n+    if (q.max_price) params.append('maxPrice', String(q.max_price));\n+    if (q.high_price) params.append('isHighPrice', 'true');\n+    if (q.liked) params.append('liked', 'true');\n+    if (q.owned) params.append('owned', 'true');\n+    if (q.poly_tags) params.append('searchPolySeekTagsOnly', 'true');\n+    if (q.sort) params.append('sort', q.sort);\n+\n+    return params;\n+  }, []);\n+\n+  const handleHistorySelect = useCallback((item: SearchHistoryItem) => {\n+    const params = buildSearchParams(item.query);\n+    router.replace(`/search?${params.toString()}`);\n+    setIsSuggestionsVisible(false);\n+  }, [router, setIsSuggestionsVisible, buildSearchParams]);\n+\n+  const handleFavoriteSelect = useCallback((item: SearchFavoriteItem) => {\n+    const params = buildSearchParams(item.query);\n+    router.replace(`/search?${params.toString()}`);\n+    setIsSuggestionsVisible(false);\n+  }, [router, setIsSuggestionsVisible, buildSearchParams]);\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 254 - 301, The\nduplicated URL param construction in handleFavoriteSelect and\nhandleHistorySelect should be extracted into a single helper (e.g.,\nbuildSearchParamsFromQuery(query)): move the logic that maps q.qâ†’q, q.tags,\nq.ntagsâ†’negativeTags, q.age_tagsâ†’ageRatingTags, q.min_priceâ†’minPrice,\nq.max_priceâ†’maxPrice, q.high_priceâ†’isHighPrice, q.likedâ†’liked, q.ownedâ†’owned,\nq.poly_tagsâ†’searchPolySeekTagsOnly, q.sortâ†’sort and the detailedFilters/category\nhandling (preserve special handling for df.category and skipping empty values)\ninto that helper; have both handlers call const params =\nbuildSearchParamsFromQuery(q) and then call\nrouter.replace(`/search?${params.toString()}`) and\nsetIsSuggestionsVisible(false) to remove the duplicated blocks while keeping\nbehavior identical.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:ocelot -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 2750819511,
    "path": "src/components/search/ProductSearch.tsx",
    "line": 450,
    "body": "_âš ï¸ Potential issue_ | _ğŸ”´ Critical_\n\n**`handleSaveFavorite`é–¢æ•°ãŒæœªå®šç¾©ã§ã™ã€‚**\n\n`onSave={handleSaveFavorite}`ã§å‚ç…§ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã®é–¢æ•°ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã§`ReferenceError`ãŒç™ºç”Ÿã—ã¾ã™ã€‚\n\n\n<details>\n<summary>ğŸ› ä¿®æ­£æ¡ˆ: handleSaveFavoriteé–¢æ•°ã‚’è¿½åŠ </summary>\n\n```diff\n   const handleFavoriteRename = useCallback((item: SearchFavoriteItem) => {\n     const newName = window.prompt('æ–°ã—ã„åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', item.name);\n     if (!newName) return;\n     const trimmed = newName.trim();\n     if (!trimmed || trimmed === item.name) return;\n     renameFavorite(item.id, trimmed);\n   }, [renameFavorite]);\n\n+  const handleSaveFavorite = useCallback(async (name: string) => {\n+    const query = getCurrentQueryObject();\n+    return await addFavorite(name, query);\n+  }, [getCurrentQueryObject, addFavorite]);\n+\n   return (\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx` around lines 445 - 450, The\ncomponent references an undefined handler onSave={handleSaveFavorite}; add a\nhandleSaveFavorite function inside the ProductSearch component that accepts the\nfavorite name, performs the existing save logic (e.g., invoke your saveFavorite\nhelper or update favorites state), closes the modal by calling\nsetIsSaveModalOpen(false), and handles errors/validation and defaultName use\n(defaultFavoriteName) as needed; reference the SaveFavoriteModal prop onSave and\nthe setter setIsSaveModalOpen so the new function integrates with the existing\nmodal flow.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:ocelot -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 2750819515,
    "path": "src/hooks/useSearchFavorite.ts",
    "line": 74,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**createdAt ã¯ã‚µãƒ¼ãƒãƒ¼å€¤ã‚’ä½¿ã£ã¦æ•´åˆæ€§ã‚’ä¿ã£ã¦ãã ã•ã„**  \nã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ™‚åˆ»ã§ä¸Šæ›¸ãã™ã‚‹ã¨ä¸¦ã³é †ã‚„è¡¨ç¤ºãŒã‚ºãƒ¬ã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ã® createdAt ã‚’æ¡ç”¨ã—ã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ’¡ ä¿®æ­£æ¡ˆ</summary>\n\n```diff\n-        const newItem: SearchFavoriteItem = {\n-          id: result.data.id,\n-          name: result.data.name,\n-          query: result.data.query as Record<string, any>,\n-          createdAt: new Date().toISOString(), // ã‚µãƒ¼ãƒãƒ¼ã®æ™‚é–“ã¨å°‘ã—ãšã‚Œã‚‹å¯èƒ½æ€§ã‚ã‚Š\n-        };\n+        const createdAt =\n+          typeof result.data.createdAt === 'string'\n+            ? result.data.createdAt\n+            : result.data.createdAt.toISOString();\n+        const newItem: SearchFavoriteItem = {\n+          id: result.data.id,\n+          name: result.data.name,\n+          query: result.data.query as Record<string, any>,\n+          createdAt,\n+        };\n```\n</details>\n\n<!-- suggestion_start -->\n\n<details>\n<summary>ğŸ“ Committable suggestion</summary>\n\n> â€¼ï¸ **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n        const createdAt =\n          typeof result.data.createdAt === 'string'\n            ? result.data.createdAt\n            : result.data.createdAt.toISOString();\n        const newItem: SearchFavoriteItem = {\n          id: result.data.id,\n          name: result.data.name,\n          query: result.data.query as Record<string, any>,\n          createdAt,\n        };\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/hooks/useSearchFavorite.ts` around lines 69 - 74, newItem currently sets\ncreatedAt using client time (new Date().toISOString()), which can cause\nordering/display inconsistencies; change it to use the server-provided timestamp\n(result.data.createdAt) when building the SearchFavoriteItem in the newItem\nconstruction (ensure result.data.createdAt is used or falls back safely if\nabsent) so createdAt reflects the server value instead of local time.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 2750819521,
    "path": "src/hooks/useSearchFavorite.ts",
    "line": 149,
    "body": "_âš ï¸ Potential issue_ | _ğŸŸ¡ Minor_\n\n**ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåç”ŸæˆãŒæ¤œç´¢ã‚­ãƒ¼ã¨ã‚ºãƒ¬ã¦ã„ã¾ã™**  \nä¿å­˜ã‚¯ã‚¨ãƒªã¯ `q` ã‚’ä½¿ã†ãŸã‚ã€`keyword` ã ã‘ã ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåãŒç©ºã«ãªã‚Šã‚„ã™ã„ã§ã™ã€‚`q` ã‚‚è¦‹ã¦ãã ã•ã„ã€‚  \n\n<details>\n<summary>ğŸ’¡ ä¿®æ­£æ¡ˆ</summary>\n\n```diff\n-    if (query.keyword) parts.push(query.keyword);\n+    if (query.q) parts.push(query.q);\n+    if (query.keyword && !query.q) parts.push(query.keyword);\n```\n</details>\n\n<details>\n<summary>ğŸ¤– Prompt for AI Agents</summary>\n\n```\nIn `@src/hooks/useSearchFavorite.ts` around lines 136 - 149, The\ngenerateDefaultName helper currently only reads query.keyword so saved favorites\ncan get empty names; update generateDefaultName to also check query.q (and fall\nback between query.keyword and query.q) when building parts, ensure it treats\nquery.q as a string (trim/skip empty) and adds it before processing tags in the\nsame function (generateDefaultName) so default names include the actual search\nterm used by the app.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:medusa:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
    "type": "review_comment"
  },
  {
    "id": 3733068303,
    "path": null,
    "line": null,
    "body": "**Actionable comments posted: 5**\n\n<details>\n<summary>ğŸ¤– Fix all issues with AI agents</summary>\n\n```\nIn `@src/app/actions/search-favorite.ts`:\n- Around line 27-65: The count-based limit can be violated by concurrent\ntransactions; to fix, inside the existing prisma.$transaction callback (the\nasync tx => { ... } block in search-favorite.ts) acquire a row-level lock on the\nuser before checking/creating favorites (e.g., issue a SELECT ... FOR UPDATE\nagainst the User row via tx.$executeRaw or read the user with a FOR UPDATE\nequivalent) so concurrent transactions for the same user are serialized; keep\nthe lock acquisition before tx.searchFavorite.count and the upsert/update logic\n(existingFavorite, tx.searchFavorite.update/create), and ensure the transaction\neither throws LIMIT_EXCEEDED or completes while holding the lock; alternatively\nyou may set the transaction isolation to 'Serializable' and implement retry\nlogic on Prisma P2034 errors, but prefer the user-row FOR UPDATE lock to\ndirectly serialize writes per user.\n\nIn `@src/components/search/ProductSearch.tsx`:\n- Around line 358-363: The current onFavoriteRename prop just re-calls\nrenameFavorite with the same item.name, so users cannot change the name; update\nthe onFavoriteRename handler (the inline arrow currently passing (item) =>\nrenameFavorite(item.id, item.name)) to collect input (e.g. via a simple prompt\nor an inline input flow) and only call renameFavorite(item.id, newName) when the\nnewName is non-empty and different from item.name; ensure you reference\nrenameFavorite and the onFavoriteRename prop so the component receives the new\nname before invoking the rename operation.\n- Around line 424-432: The current favorites check always returns true because\nit compares f.query to a shallow clone of itself; change the predicate to\ncompare each favorite's query to the current search criteria (e.g., replace\nJSON.stringify({ ...f.query }) with a stable snapshot of the current query state\nsuch as JSON.stringify(currentQuery) or use a deep equality helper like\nisEqual(f.query, currentQuery)); update the favorites.some(...) expression\ninside ProductSearch (where favorites and the Star/Button rendering occur) to\nuse that comparison so the star is only filled when a favorite exactly matches\nthe current search query.\n\nIn `@src/components/search/TagSearchBar.tsx`:\n- Around line 348-380: The tab header inside TagSearchBar currently sits within\nthe listbox and may be exposed as options to screen readers; update the\ncontaining div (the element with class \"flex border-b border-gray-200\ndark:border-gray-700 bg-gray-50 dark:bg-gray-800 sticky top-0 z-10\" that wraps\nthe two buttons using setActiveTab('history') and setActiveTab('favorites')) to\nbe ignored by assistive tech by adding role=\"presentation\" (or move the whole\nheader out of the listbox if you prefer structural change) so the buttons are\nnot misinterpreted as listbox options.\n\nIn `@src/hooks/useSearchFavorite.ts`:\n- Around line 96-113: The removeFavorite optimistic update currently mutates\nstate without rollback; capture the previous favorites before calling\nsetFavorites in removeFavorite, then call deleteFavoriteApi(id) and if\nresult.success is false or an exception is thrown restore the saved previous\nlist (or trigger a refetch) so the UI stays consistent; specifically, inside\nremoveFavorite save prevFavorites (from setFavorites callback or a local\nvariable), perform setFavorites(prev => prev.filter(...)), await\ndeleteFavoriteApi(id), and on failure or in catch restore prevFavorites via\nsetFavorites or call the existing fetch function to re-sync.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit for review status -->",
    "type": "review_summary"
  },
  {
    "id": 3733371138,
    "path": null,
    "line": null,
    "body": "**Actionable comments posted: 2**\n\n<details>\n<summary>ğŸ¤– Fix all issues with AI agents</summary>\n\n```\nIn `@src/components/search/ProductSearch.tsx`:\n- Around line 123-129: The current loop building cleanFilters drops falsy but\nvalid values (e.g., false, 0) because it uses if (detailedFilters[key]); update\nthe filter-preservation logic in ProductSearch (the detailedFilters ->\ncleanFilters block) to only exclude null, undefined, and empty-string values\nwhile keeping 0/false; keep the Object.keys(detailedFilters).sort() iteration\nand ensure after assigning query.detailedFilters = cleanFilters you still copy\ncategory with if (cleanFilters.category) replaced by a check that treats\nempty-string/null/undefined as excluded so a valid false/0 category is preserved\nas appropriate.\n- Around line 152-166: The normalize function used inside\nisCurrentConditionFavorited mutates arrays by calling obj.sort(), which can\nchange favorites state during render; update normalize (used by\nisCurrentConditionFavorited/getCurrentQueryObject) to perform a non-destructive,\nrecursive normalization: when obj is an array, create a shallow copy (e.g.,\n[...obj]) before sorting and recursively normalize each element (and for\nobjects, recursively normalize each value while sorting keys) so no mutation of\nfavorites occurs and comparison remains stable.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit for review status -->",
    "type": "review_summary"
  },
  {
    "id": 3735299577,
    "path": null,
    "line": null,
    "body": "**Actionable comments posted: 6**\n\n<details>\n<summary>ğŸ¤– Fix all issues with AI agents</summary>\n\n```\nIn `@src/app/actions/search-favorite.ts`:\n- Around line 141-168: Trim the incoming newName once and use the trimmed value\nthroughout: validate using trimmedName (check empty), use trimmedName in the\nuniqueness check via prisma.searchFavorite.findUnique, and set name: trimmedName\nin prisma.searchFavorite.updateMany so stored and compared values don't include\nsurrounding whitespace; keep references to session.user.id, id,\nprisma.searchFavorite.findUnique and prisma.searchFavorite.updateMany when\nmaking the change.\n- Around line 22-38: Normalize the incoming name by trimming (and optionally\ncollapsing internal whitespace) before any checks or DB operations so duplicate\ndetection and storage use the same value; update the code in search-favorite.ts\nto compute a normalizedName (use normalizedName instead of name) before the\nempty check, before the tx.$executeRaw lock, in the tx.searchFavorite.findUnique\nwhere clause (userId_name), and when creating/updating the favorite so both\nreads and writes use the trimmed value consistently.\n\nIn `@src/components/search/ProductSearch.tsx`:\n- Around line 254-301: The duplicated URL param construction in\nhandleFavoriteSelect and handleHistorySelect should be extracted into a single\nhelper (e.g., buildSearchParamsFromQuery(query)): move the logic that maps\nq.qâ†’q, q.tags, q.ntagsâ†’negativeTags, q.age_tagsâ†’ageRatingTags,\nq.min_priceâ†’minPrice, q.max_priceâ†’maxPrice, q.high_priceâ†’isHighPrice,\nq.likedâ†’liked, q.ownedâ†’owned, q.poly_tagsâ†’searchPolySeekTagsOnly, q.sortâ†’sort\nand the detailedFilters/category handling (preserve special handling for\ndf.category and skipping empty values) into that helper; have both handlers call\nconst params = buildSearchParamsFromQuery(q) and then call\nrouter.replace(`/search?${params.toString()}`) and\nsetIsSuggestionsVisible(false) to remove the duplicated blocks while keeping\nbehavior identical.\n- Around line 445-450: The component references an undefined handler\nonSave={handleSaveFavorite}; add a handleSaveFavorite function inside the\nProductSearch component that accepts the favorite name, performs the existing\nsave logic (e.g., invoke your saveFavorite helper or update favorites state),\ncloses the modal by calling setIsSaveModalOpen(false), and handles\nerrors/validation and defaultName use (defaultFavoriteName) as needed; reference\nthe SaveFavoriteModal prop onSave and the setter setIsSaveModalOpen so the new\nfunction integrates with the existing modal flow.\n\nIn `@src/hooks/useSearchFavorite.ts`:\n- Around line 136-149: The generateDefaultName helper currently only reads\nquery.keyword so saved favorites can get empty names; update generateDefaultName\nto also check query.q (and fall back between query.keyword and query.q) when\nbuilding parts, ensure it treats query.q as a string (trim/skip empty) and adds\nit before processing tags in the same function (generateDefaultName) so default\nnames include the actual search term used by the app.\n- Around line 69-74: newItem currently sets createdAt using client time (new\nDate().toISOString()), which can cause ordering/display inconsistencies; change\nit to use the server-provided timestamp (result.data.createdAt) when building\nthe SearchFavoriteItem in the newItem construction (ensure result.data.createdAt\nis used or falls back safely if absent) so createdAt reflects the server value\ninstead of local time.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit for review status -->",
    "type": "review_summary"
  },
  {
    "id": 3828833816,
    "path": null,
    "line": null,
    "body": "<!-- This is an auto-generated comment: summarize by coderabbit.ai -->\n<!-- walkthrough_start -->\n\n<details>\n<summary>ğŸ“ Walkthrough</summary>\n\n## Walkthrough\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«æ¤œç´¢æ¡ä»¶ã‚’ä¿å­˜ãƒ»ç®¡ç†ã™ã‚‹ã€ŒãŠæ°—ã«å…¥ã‚Šæ¤œç´¢ã€æ©Ÿèƒ½ã‚’è¿½åŠ ã€‚Prisma ã‚¹ã‚­ãƒ¼ãƒã¨ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚µãƒ¼ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€useSearchFavorite ãƒ•ãƒƒã‚¯ã€SaveFavoriteModalã€TagSearchBar/ProductSearch ã® UI çµ±åˆã‚’å®Ÿè£…ã€‚\n\n## Changes\n\n|Cohort / File(s)|Summary|\n|---|---|\n|**ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ / Prisma** <br> `prisma/migrations/20260131163033_add_search_favorite/migration.sql`, `prisma/schema.prisma`|æ–°ã—ã„ `SearchFavorite` ãƒ¢ãƒ‡ãƒ«ã‚’è¿½åŠ ã€‚`id` PKã€`userId` FK (ON DELETE/UPDATE CASCADE)ã€`query` ã¯ JSON/JSONBã€`(userId, name)` ã« UNIQUEã€`userId` ã¨ `createdAt` ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚`User.favorites` ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ ã€‚|\n|**ã‚µãƒ¼ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³** <br> `src/app/actions/search-favorite.ts`|`saveSearchFavorite`, `getSearchFavorites`, `deleteSearchFavorite`, `renameSearchFavorite` ã‚’è¿½åŠ ã€‚ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œè¨¼ãƒ»æ‰€æœ‰ãƒã‚§ãƒƒã‚¯ã€15ä»¶ä¸Šé™ã®æ¤œæŸ»ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³/ã‚¢ãƒƒãƒ—ã‚µãƒ¼ãƒˆãƒ»å‰Šé™¤ãƒ»æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ã€‚|\n|**ãƒ•ãƒƒã‚¯** <br> `src/hooks/useSearchFavorite.ts`|`SearchFavoriteItem` å‹ã¨ `useSearchFavorite` ãƒ•ãƒƒã‚¯ã‚’è¿½åŠ ã€‚èªè¨¼é€£å‹•ã§ã®èª­ã¿è¾¼ã¿ã€æ¥½è¦³æ›´æ–°ï¼ˆadd/remove/renameï¼‰ã€ã‚µãƒ¼ãƒãƒ¼å‘¼ã³å‡ºã—ãƒ©ãƒƒãƒ‘ãƒ¼ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåç”Ÿæˆã‚’å®Ÿè£…ã€‚|\n|**UI: ProductSearch** <br> `src/components/search/ProductSearch.tsx`|`useSearchFavorite` çµ±åˆã€SaveFavoriteModal ã®è¡¨ç¤ºã¨ä¿å­˜ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã€ç¾åœ¨ã‚¯ã‚¨ãƒªã®æ­£è¦åŒ–ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆgetCurrentQueryObjectï¼‰ã€ã‚¹ã‚¿ãƒ¼UIè¡¨ç¤ºã€favorite é¸æŠ/å‰Šé™¤/ãƒªãƒãƒ¼ãƒ ãƒãƒ³ãƒ‰ãƒ©è¿½åŠ ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ—ãƒ­ãƒƒãƒ—ã‚·ã‚°ãƒãƒãƒ£æ‹¡å¼µã€‚|\n|**UI: TagSearchBar** <br> `src/components/search/TagSearchBar.tsx`|å±¥æ­´ã¨ãŠæ°—ã«å…¥ã‚Šã‚’åˆ‡æ›¿ãˆã‚‹ã‚¿ãƒ– UI ã‚’è¿½åŠ ã€‚å±¥æ­´ã¨ favorites ã®å…±é€šè¡¨ç¤ºï¼ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ˆé¸æŠãƒ»å‰Šé™¤ãƒ»ãƒªãƒãƒ¼ãƒ ï¼‰ã‚’å®Ÿè£…ã€‚favorites ç”¨ãƒ—ãƒ­ãƒƒãƒ—ã‚’è¿½åŠ ã€‚|\n|**UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ** <br> `src/components/search/SaveFavoriteModal.tsx`|ãŠæ°—ã«å…¥ã‚Šä¿å­˜ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¿½åŠ ã€‚æœªèªè¨¼æ™‚ã®ãƒ­ã‚°ã‚¤ãƒ³ä¿ƒé€²ã€å…¥åŠ›æ¤œè¨¼ã€éåŒæœŸä¿å­˜ãƒ•ãƒ­ãƒ¼ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€ãƒœã‚¿ãƒ³çŠ¶æ…‹åˆ¶å¾¡ã‚’å®Ÿè£…ã€‚|\n|**ãƒ¡ã‚¿/ã‚³ãƒ¡ãƒ³ãƒˆç­‰** <br> `.coderabbit_comments.json`, `coderabbit_filtered.json`, `issue_comments.json`, `pr_comments.json`, `raw_comments.json`|ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆï¼ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ï¼ˆAI ã‚³ãƒ¡ãƒ³ãƒˆã€issue/pr ã‚³ãƒ¡ãƒ³ãƒˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ææ¡ˆï¼‰ã€‚å‹•ä½œã‚³ãƒ¼ãƒ‰ã§ã¯ãªã„ãŒæ¤œè¨äº‹é …å¤šæ•°ã€‚|\n\n## ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³\n\n```mermaid\nsequenceDiagram\n    actor User\n    participant ProductSearch as ProductSearch\n    participant SaveModal as SaveFavoriteModal\n    participant Hook as useSearchFavorite\n    participant ServerAction as ServerAction\n    participant Prisma as Prisma\n    participant DB as Database\n\n    User->>ProductSearch: ä¿å­˜ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯\n    ProductSearch->>SaveModal: open(defaultName)\n    User->>SaveModal: åå‰å…¥åŠ›ã—ã¦ä¿å­˜\n    SaveModal->>Hook: addFavorite(name, query)\n    Hook->>ServerAction: saveSearchFavorite(name, query)\n    ServerAction->>Prisma: upsert/create SearchFavorite\n    Prisma->>DB: INSERT/UPDATE\n    DB-->>Prisma: success\n    Prisma-->>ServerAction: record\n    ServerAction-->>Hook: { success, data }\n    Hook->>Hook: ãƒ­ãƒ¼ã‚«ãƒ« state ã‚’æ¥½è¦³çš„æ›´æ–°\n    Hook-->>SaveModal: { success: true }\n    SaveModal-->>ProductSearch: close / onSave\n    ProductSearch->>ProductSearch: UI æ›´æ–°ï¼ˆä¿å­˜æ¸ˆè¡¨ç¤ºï¼‰\n```\n\n```mermaid\nsequenceDiagram\n    participant TagSearchBar as TagSearchBar\n    participant Hook as useSearchFavorite\n    participant ServerAction as ServerAction\n    participant DB as Database\n\n    Note over TagSearchBar: ãƒã‚¦ãƒ³ãƒˆã¾ãŸã¯èªè¨¼å¤‰åŒ–\n    TagSearchBar->>Hook: favorites ã‚’è¦æ±‚\n    Hook->>ServerAction: getSearchFavorites()\n    ServerAction->>DB: SELECT * FROM SearchFavorite WHERE userId = ?\n    DB-->>ServerAction: rows\n    ServerAction-->>Hook: { success, data }\n    Hook-->>TagSearchBar: favorites[]\n    User->>TagSearchBar: ã‚¿ãƒ–ã§ã€ŒFavoritesã€ã‚’é¸æŠ\n    TagSearchBar->>TagSearchBar: favorites ã‚’è¡¨ç¤º / æ“ä½œ\n```\n\n## Estimated code review effort\n\nğŸ¯ 3 (Moderate) | â±ï¸ ~22 åˆ†\n\n## Possibly related PRs\n\n- udondon1478/Project-PS#144 â€” ProductSearch ã®ãƒ—ãƒ­ãƒƒãƒ—ã‚·ã‚°ãƒãƒãƒ£å¤‰æ›´ã¨é‡è¤‡ã®å¯èƒ½æ€§ã‚ã‚Šã€‚  \n- udondon1478/Project-PS#221 â€” TagSearchBar ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°/ææ¡ˆãƒ­ã‚¸ãƒƒã‚¯å¤‰æ›´ã¨é‡ãªã‚ŠãŒã‚ã‚‹å¯èƒ½æ€§ã‚ã‚Šã€‚\n\n## è©©\n\n> ğŸ¥•âœ¨ ãƒã‚±ãƒƒãƒˆã«ã²ã¨ã¤ã‚¯ã‚¨ãƒªã‚’ã—ã¾ã£ã¦ã€  \n> æ˜Ÿã‚’æŠ¼ã›ã°ã¾ãŸå‘¼ã³å‡ºã™ã‚ˆã€  \n> åäº”ã¾ã§æ•°ãˆã¦å¤§äº‹ã«ç½®ãã€  \n> ã†ã•ãã¯ã´ã‚‡ã‚“ã¨ä¿å­˜ã®éµã‚’ã‹ã‘ã‚‹ã€  \n> ã»ã‚‰ã€æ¤œç´¢ãŒã¾ãŸã‚­ãƒ©ãƒªã¨ç¬‘ã†ã‚ˆğŸ°ğŸŒŸ\n\n</details>\n\n<!-- walkthrough_end -->\n\n\n<!-- pre_merge_checks_walkthrough_start -->\n\n<details>\n<summary>ğŸš¥ Pre-merge checks | âœ… 2 | âŒ 1</summary>\n\n<details>\n<summary>âŒ Failed checks (1 warning)</summary>\n\n|     Check name     | Status     | Explanation                                                                           | Resolution                                                                         |\n| :----------------: | :--------- | :------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------- |\n| Docstring Coverage | âš ï¸ Warning | Docstring coverage is 66.67% which is insufficient. The required threshold is 80.00%. | Write docstrings for the functions missing them to satisfy the coverage threshold. |\n\n</details>\n<details>\n<summary>âœ… Passed checks (2 passed)</summary>\n\n|     Check name    | Status   | Explanation                                                           |\n| :---------------: | :------- | :-------------------------------------------------------------------- |\n| Description Check | âœ… Passed | Check skipped - CodeRabbitâ€™s high-level summary is enabled.           |\n|    Title check    | âœ… Passed | ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¿ã‚¤ãƒˆãƒ«ã¯ãŠæ°—ã«å…¥ã‚Šæ¤œç´¢æ©Ÿèƒ½ã®å®Ÿè£…ã¨ã„ã†ä¸»è¦ãªå¤‰æ›´ã‚’æ˜ç¢ºã«ç¤ºã—ã¦ãŠã‚Šã€å¤‰æ›´ã‚»ãƒƒãƒˆå…¨ä½“ã®ä¸­å¿ƒçš„ãªç›®çš„ã‚’æ­£ç¢ºã«è¦ç´„ã—ã¦ã„ã¾ã™ã€‚ |\n\n</details>\n\n<sub>âœï¸ Tip: You can configure your own custom pre-merge checks in the settings.</sub>\n\n</details>\n\n<!-- pre_merge_checks_walkthrough_end -->\n\n<!-- finishing_touch_checkbox_start -->\n\n<details>\n<summary>âœ¨ Finishing touches</summary>\n\n- [ ] <!-- {\"checkboxId\": \"7962f53c-55bc-4827-bfbf-6a18da830691\"} --> ğŸ“ Generate docstrings\n<details>\n<summary>ğŸ§ª Generate unit tests (beta)</summary>\n\n- [ ] <!-- {\"checkboxId\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\", \"radioGroupId\": \"utg-output-choice-group-unknown_comment_id\"} -->   Create PR with unit tests\n- [ ] <!-- {\"checkboxId\": \"07f1e7d6-8a8e-4e23-9900-8731c2c87f58\", \"radioGroupId\": \"utg-output-choice-group-unknown_comment_id\"} -->   Post copyable unit tests in a comment\n- [ ] <!-- {\"checkboxId\": \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", \"radioGroupId\": \"utg-output-choice-group-unknown_comment_id\"} -->   Commit unit tests in branch `search-favorite`\n\n</details>\n\n</details>\n\n<!-- finishing_touch_checkbox_end -->\n\n<!-- tips_start -->\n\n---\n\nThanks for using [CodeRabbit](https://coderabbit.ai?utm_source=oss&utm_medium=github&utm_campaign=udondon1478/Project-PS&utm_content=288)! It's free for OSS, and your support helps us grow. If you like it, consider giving us a shout-out.\n\n<details>\n<summary>â¤ï¸ Share</summary>\n\n- [X](https://twitter.com/intent/tweet?text=I%20just%20used%20%40coderabbitai%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20the%20proprietary%20code.%20Check%20it%20out%3A&url=https%3A//coderabbit.ai)\n- [Mastodon](https://mastodon.social/share?text=I%20just%20used%20%40coderabbitai%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20the%20proprietary%20code.%20Check%20it%20out%3A%20https%3A%2F%2Fcoderabbit.ai)\n- [Reddit](https://www.reddit.com/submit?title=Great%20tool%20for%20code%20review%20-%20CodeRabbit&text=I%20just%20used%20CodeRabbit%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20proprietary%20code.%20Check%20it%20out%3A%20https%3A//coderabbit.ai)\n- [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fcoderabbit.ai&mini=true&title=Great%20tool%20for%20code%20review%20-%20CodeRabbit&summary=I%20just%20used%20CodeRabbit%20for%20my%20code%20review%2C%20and%20it%27s%20fantastic%21%20It%27s%20free%20for%20OSS%20and%20offers%20a%20free%20trial%20for%20proprietary%20code)\n\n</details>\n\n<sub>Comment `@coderabbitai help` to get the list of available commands and usage tips.</sub>\n\n<!-- tips_end -->\n\n<!-- internal state start -->\n\n\n<!-- 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 -->\n\n<!-- internal state end -->",
    "type": "issue_comment"
  }
]
